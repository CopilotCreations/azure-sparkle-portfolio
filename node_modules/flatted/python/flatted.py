# ISC License
#
# Copyright (c) 2018-2025, Andrea Giammarchi, @WebReflection
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import json as _json

class _Known:
    """Internal class to track known keys and values during serialization."""

    def __init__(self):
        """Initialize empty key and value lists."""
        self.key = []
        self.value = []

class _String:
    """Internal wrapper class for string values during parsing."""

    def __init__(self, value):
        """Initialize with a string value.

        Args:
            value: The string value to wrap.
        """
        self.value = value


def _array_keys(value):
    """Generate a list of numeric indices for an array.

    Args:
        value: A list or tuple to generate indices for.

    Returns:
        A list of integer indices from 0 to len(value)-1.
    """
    keys = []
    i = 0
    for _ in value:
        keys.append(i)
        i += 1
    return keys

def _object_keys(value):
    """Generate a list of keys from a dictionary.

    Args:
        value: A dictionary to extract keys from.

    Returns:
        A list of keys from the dictionary.
    """
    keys = []
    for key in value:
        keys.append(key)
    return keys

def _is_array(value):
    """Check if a value is an array (list or tuple).

    Args:
        value: The value to check.

    Returns:
        True if value is a list or tuple, False otherwise.
    """
    return isinstance(value, (list, tuple))

def _is_object(value):
    """Check if a value is an object (dictionary).

    Args:
        value: The value to check.

    Returns:
        True if value is a dict, False otherwise.
    """
    return isinstance(value, dict)

def _is_string(value):
    """Check if a value is a string.

    Args:
        value: The value to check.

    Returns:
        True if value is a str, False otherwise.
    """
    return isinstance(value, str)

def _index(known, input, value):
    """Add a value to the input list and track it in known.

    Args:
        known: A _Known instance tracking seen keys and values.
        input: The list of input values being built.
        value: The value to add and index.

    Returns:
        The string index of the newly added value.
    """
    input.append(value)
    index = str(len(input) - 1)
    known.key.append(value)
    known.value.append(index)
    return index

def _loop(keys, input, known, output):
    """Process keys in output, resolving string references.

    Args:
        keys: List of keys to iterate over in output.
        input: The list of parsed input values.
        known: List of already-processed values to avoid cycles.
        output: The output structure being populated.

    Returns:
        The populated output structure.
    """
    for key in keys:
        value = output[key]
        if isinstance(value, _String):
            _ref(key, input[int(value.value)], input, known, output)

    return output

def _ref(key, value, input, known, output):
    """Resolve a reference and assign it to output[key].

    Args:
        key: The key in output to assign the resolved value to.
        value: The value to resolve (may be array or object).
        input: The list of parsed input values.
        known: List of already-processed values to avoid cycles.
        output: The output structure being populated.
    """
    if _is_array(value) and value not in known:
        known.append(value)
        value = _loop(_array_keys(value), input, known, value)
    elif _is_object(value) and value not in known:
        known.append(value)
        value = _loop(_object_keys(value), input, known, value)

    output[key] = value

def _relate(known, input, value):
    """Get or create an index reference for a value.

    Args:
        known: A _Known instance tracking seen keys and values.
        input: The list of input values being built.
        value: The value to relate.

    Returns:
        The index reference if value is string/array/object, otherwise
        the original value.
    """
    if _is_string(value) or _is_array(value) or _is_object(value):
        try:
            return known.value[known.key.index(value)]
        except:
            return _index(known, input, value)

    return value

def _transform(known, input, value):
    """Transform a value by replacing nested values with references.

    Args:
        known: A _Known instance tracking seen keys and values.
        input: The list of input values being built.
        value: The value to transform.

    Returns:
        A transformed copy with nested values replaced by index references.
    """
    if _is_array(value):
        output = []
        for val in value:
            output.append(_relate(known, input, val))
        return output

    if _is_object(value):
        obj = {}
        for key in value:
            obj[key] = _relate(known, input, value[key])
        return obj

    return value

def _wrap(value):
    """Wrap string values in _String objects recursively.

    Args:
        value: The value to wrap.

    Returns:
        The value with all strings wrapped in _String objects.
    """
    if _is_string(value):
        return _String(value)

    if _is_array(value):
        i = 0
        for val in value:
            value[i] = _wrap(val)
            i += 1

    elif _is_object(value):
        for key in value:
            value[key] = _wrap(value[key])

    return value

def parse(value, *args, **kwargs):
    """Parse a flatted JSON string into a Python object.

    Args:
        value: A flatted JSON string to parse.
        *args: Additional positional arguments passed to json.loads.
        **kwargs: Additional keyword arguments passed to json.loads.

    Returns:
        The parsed Python object with circular references restored.
    """
    json = _json.loads(value, *args, **kwargs)
    wrapped = []
    for value in json:
        wrapped.append(_wrap(value))

    input = []
    for value in wrapped:
        if isinstance(value, _String):
            input.append(value.value)
        else:
            input.append(value)

    value = input[0]

    if _is_array(value):
        return _loop(_array_keys(value), input, [value], value)

    if _is_object(value):
        return _loop(_object_keys(value), input, [value], value)

    return value


def stringify(value, *args, **kwargs):
    """Serialize a Python object to a flatted JSON string.

    Args:
        value: The Python object to serialize.
        *args: Additional positional arguments passed to json.dumps.
        **kwargs: Additional keyword arguments passed to json.dumps.

    Returns:
        A flatted JSON string that preserves circular references.
    """
    known = _Known()
    input = []
    output = []
    i = int(_index(known, input, value))
    while i < len(input):
        output.append(_transform(known, input, input[i]))
        i += 1
    return _json.dumps(output, *args, **kwargs)
